# 学习记录

## F1 如何科学地提问

一、 在提问前先准备好一下三个方面

- "搜搜友好的网络"(STFW)：当你得到一个关键词的话，你就可以通过搜索引擎去搜索一下关键粗
- "读读友好的手册"(RTFM)：如果软件或者工具有手册（手册一般在官网，你通过“STFW”，找到这个官网）你应该先去阅读一下他们手册。或者去对应的github仓库查看一下大家提的issue，是否有和自己同类型的问题；
- "读读友好的源代码"(RTFSC)：应该尝试去读一下它们的源代码；

二、如何正确描述问题？

1. 环境（操作系统类型、一些关键的软件的版本等等）；
2. 做了什么操作导致出现了这个问题；
3. 错误的表现是什么样式的；
4. 最好带上截图，可以的话截图中圈出关键点；
5. 也可以补充一些提这个问题的目的；（因为很多初学者不是能很好的意识到这个到底是不是一个问题）

提问模板：https://ysyx.oscc.cc/docs/2205/misc/ask.html

## F2 Logisim

我下载的时候默认是中文，所以看起来会比较轻松，如果遇到不会的，优先去帮助里面查看文档，我们称之为STFW。

### 快捷键

![OneStudentOneChip/image/image.png](../image/4.png)

### 数电和模电

自行复习

## F3 数字逻辑电路基础

### 晶体管

常用的晶体管是 金属-氧化物-半导体场效应晶体管，简称MOS管，MOS管有分为nMOS(Negative)和pMOS(Positive)，它们都有三个接口，分别是栅极(gete)，源极(source)和漏极(drain)。晶体管是一个特殊的开关, 它是由电路中的电压来控制的. 通过控制MOS管栅极的电压, 来控制其源极和漏极是否连通。

![OneStudentOneChip/image/5.png](../image/5.png)

nMOS功能

- 当栅极电压与源极电压之间的差值(V~G~-V~S~)较大时，源极和漏极导通，相当于开关闭合
- 当栅极电压与源极电压之间的差值(V~G~-V~S~)较小时，源极和漏极截止，相当于开关断开

pMOS功能表现与nMOS类似，V~S~-V~G~较大时导通，V~S~-V~G~较小时截止。

由于nMOS和pMOS具有互补的特性，在数字电路中通常将两者联合使用，称为CMOS技术：

![OneStudentOneChip/image/6.png](../image/6.png)

- 在A点加高电压时, 下方的n管(nMOS)导通, 上方的p管(pMOS)截止, 相当于Y点与地相连(中图), Y点电压低
- 在A点加低电压时, 下方的n管(nMOS)截止, 上方的p管(pMOS)导通, 相当于Y点与电源相连(右图), Y点电压高

因此可以看到，CMOS电路将n管和p管的开关特性转换成了电路输出电压的高低，将物理上的高电压定义为逻辑1

(高电平)，低电压定义为逻辑0(低电平)，于是便得到了数字电路中信号的两种基本状态。

### 通过晶体管搭建门电路

#### 非门（反相器）

上面提到的CMOS电路就是一个非门，当A输出为1的时候，Y输出为0；当A输出为0的时候，Y输出为1；

#### 与非门

![OneStudentOneChip/image/7.png](../image/7.png)

P1和P2并联，N1和N2串联，所以P1和P2只要以一个导通时，Y就为1，N1和N2需要两个都导通时才为0

只有当两个输出都为1的时候，电路才会输出0，否则输出1。

#### 与门

将与非门的输出再连接一个非门就是与门

![OneStudentOneChip/image/8.png](../image/8.png)

#### 或门

![OneStudentOneChip/image/9.png](../image/9.png)

上面的电路图，在他的后面加上一个非门即可变成或门![OneStudentOneChip/image/10.png](../image/10.png)

#### 全定制电路：通过晶体管设计电路

在晶体管层次设计的电路称为全定制电路，通过三输入与非门的例子，我们可以看到，全定制电路所需要的晶体管的数量更少，因此电路面积也更小，在实际生产中，出了面积更小之外，全定制电路的主频也更高，功耗更低。

但是, 全定制电路的设计难度大, 开发周期也很长. 现代处理器芯片包含动辄上亿个晶体管, 全部使用全定制电路来开发是不现实的. 对于超大规模集成电路的设计, 更常见的是采用的是半定制电路设计方法.

半定制电路的设计又分为基于标准单元的设计方法和基于门阵列的设计方法. 前者是预先用全定制方式设计出一些常用的逻辑单元, 例如与门、或门、触发器等, 这些逻辑单元称为标准单元; 然后再通过这些标准单元构建出大规模电路. 回到上面三输入与非门的例子, 如果把两输入的与门和两输入的与非门看成是标准单元, 那么通过它们搭建三输入与非门就可以看成是半定制电路的设计方法. 至于基于门阵列的设计方法, 一个常见的例子是FPGA. 

#### 异或门

![OneStudentOneChip/image/11.png](../image/11.png)

异或门只有当连哥哥输入信号不同时，输出才为高电平，如果两个输入相同，输出则为低电平。

- 异或的“异”表示“不同”，因此当输入A和B不同时，结果为1，否则为0.
- 或运算表示两个输入中至少一个为1，和或运算不同，异或运算排除了两个输入均为1的情况，因此也成为“排斥或”，其中的“排斥”和英文exclusive对应，相对地，或运算也称为“相容或”，表示允许两个输入均为1。

异或门的全定制电路

![OneStudentOneChip/image/12.png](../image/12.png)

接线图：test04

![OneStudentOneChip/image/13.png](../image/13.png)

![OneStudentOneChip/image/14.png](../image/14.png)

异或门电路解析：只使用6个晶体管

我们把整个电路图分为三部分，如图左半边输出：![OneStudentOneChip/image/15.png](../image/15.png)、中间输出![!OneStudentOneChip/image/16.png](../image/16.png)，右半边输出：![OneStudentOneChip/image/17.png](../image/17.png)

左边提供了A/~A![OneStudentOneChip/image/18.png](../image/18.png)，中间电路重要完成当A/B不同时输出为1，通过将B与A和非A进行比较，控制开关，实现对A/B输出不同时，Y输出为1。右边电路实现A/B相同时，输出为0，左边的电路当A/B相同的时候是不接通输出到Y的电路的，右边的电路和中间的电路是一样的，只是晶体管的栅极和源极之间的输入与中间调换了一下，实现A/B相同输出0的道理，

#### 同或门

test06即对上面异或门的输出再接一个非门电路

六个晶体管的全定制实现：

![OneStudentOneChip/image/19.png](../image/19.png)

这里的同或门把右边两部门的p/n晶体管换个位置

### 化简算法

#### 1. QMC 算法 (Quine-McCluskey Method)

QMC 算法也被称为“表格法”，它是第一个能够通过计算机编程实现并**保证找到最优解**的化简算法。

##### 工作流程：

1. **分组**：将所有最小项（Minterms）按照包含“1”的个数进行分组。
2. **寻找质蕴涵项 (Prime Implicants)**：
   - 比较相邻组的项，如果只有一位不同，则合并，并用横杠 `-` 代替变化的那一位。
   - 重复此过程，直到无法再合并为止。剩下的项就是“质蕴涵项”。
3. **构建质蕴涵表 (PI Chart)**：
   - 列出所有最小项和所有找到的质蕴涵项。
   - 找出**必须包含**的项（必要质蕴涵项，EPI），它们覆盖了那些没有其他项能覆盖的最小项。
4. **选择最小覆盖**：用最少的质蕴涵项覆盖剩下的所有最小项。

##### 优缺点：

- **优点**：能保证得到逻辑最简式（最优解）。
- **缺点**：随着变量增加，计算量呈指数级增长（NP-complete 问题），处理超过 10 个变量时速度极慢。

------

#### 2. Espresso 算法

Espresso 是一种**启发式（Heuristic）**算法，由 UC Berkeley 开发。它是工业界（如 EDA 工具、FPGA 编译器）的实际标准。

##### 核心思想：

它不像 QMC 那样枚举所有可能性，而是通过**迭代优化**来快速逼近最优解。它不保证 100% 找到“绝对最简”，但在 99.9% 的情况下能找到非常接近最优且足够好的解，而且速度极快。

##### 关键步骤 (Reduce-Expand-Irredundant)：

1. **Expand（展开）**：尝试把现有的积项变大（把 0 或 1 变成 `-`），目的是覆盖更多的 1，从而减少总项数。
2. **Irredundant（去冗余）**：删除那些已经被其他项覆盖掉的多余项。
3. **Reduce（收缩）**：将现有的项尽量缩小，腾出空间，以便在下一轮“展开”中尝试不同的方向，跳出局部最优解。

##### 优缺点：

- **优点**：处理能力强，可以轻松处理几十个甚至上百个变量的复杂逻辑。
- **缺点**：在极少数极端情况下，结果可能不是数学上的绝对最简。

### 进位计数法

十进制、二进制、十六进制...

### 门电路搭建基本组合逻辑电路

#### 译码器

一个2-4译码器

![OneStudentOneChip/image/20.png](../image/20.png)

##### 译码器的扩展

3-8译码器有3位输入, 8位输出. 尝试实例化若干个2-4译码器(具体数量交给你的思考), 并添加少量门电路, 从而实现3-8译码器的功能

分析：将两个2-4译码器分别作为高四位和低四位的输出，将两个输入分别接入，再额外加一个控制何时读取高四位和低四位，加一个控制，与门来控制选中高四位还是低四位。

接线图：

![OneStudentOneChip/image/21.png](../image/21.png)

#### 转码器

它可以按照指定的规则将一种编码的输入转换成另一种编码的输出，和n选1译码器不同，转码器不要求输出中最多包含1个1。

转码器的一个常见应用是七段数码管译码器(7-segment decoder). 七段数码管是一个由7段发光二极管按"8"字型排列组成的输出元件，图中用字母a-g分别标识每一段发光二极管的位置, 只要某控制信号有效, 相应的发光二极管就会被点亮. 图中还有一个用h标识的小数点, 在一些需要使用小数的场景会使用.![OneStudentOneChip/image/22.png](../image/22.png)

电路图解析：

使用了两个前面搭建了3-8译码器，搭建了一个4输入16输出的译码器，搭建方式和2-4搭3-8原理一致

具体电路图：

![OneStudentOneChip/image/23.png](../image/23.png)

搭建七段数码管编码器2：

原理同上：

![OneStudentOneChip/image/24.png](../image/24.png)

#### 编码器

编码器的功能和n选1译码器相反，它用于将独热码转换成相应的二进制数值。

在Logisim中通过门电路搭建一个16-4编码器, 它有16位输入和4位输出, 分别与拨码开关和七段数码管译码器相连, 使得编码器的输出结果通过十六进制数字显示在七段数码管中
电路图：

![OneStudentOneChip/image/25.png](../image/25.png)

![OneStudentOneChip/image/26.png](../image/26.png)

其中未展示的multDigital是前面搭建的七段数码管电路。

##### 优先编码器

上述编码器要求使用者保证输入是独热码, 如果希望在输入不为独热码的时候仍然输出有效的信息, 则需要使用另一种编码器——优先编码器(priority encoder).

搭建4-2优先编码器，电路图：左边是优先编码器，右边是普通编码器

![OneStudentOneChip/image/27.png](../image/27.png)![OneStudentOneChip/image/28.png](../image/28.png)

对比4-2编码器和4-2优先编码器，可以发现，4-2优先编码器相较于普通编码器而言，需要多两个与门和两个或门，以此来实现输入不必强求为标准的独热码。

##### 优先编码器的扩展

![OneStudentOneChip/image/29.png](../image/29.png)

电路解析，整体思路位先实现16-4的编码器，先选用四个4-2优先编码器，连接它们的输出到一个四输出的或门，这样即可实现低两位的控制，高四位的实现在于通过一个标志位，或门输出，来标识哪一个4-2编码器被激活，从而实现对高两位的控制。

细节实现：

1. **输入组编码层 (第一级)**

- 使用了 **4个 `four Intwo Out` 模块** 接收16位拨码开关信号。
- 每个模块负责4位输入，并独立生成该组内的 2-bit 编码结果。
- **关键点：** 通过外部的 4 输入或门（标记为 **v1, v2, v3, v4**）提取了每一组的**有效信号（Valid）**。

2. **组间优先级拦截逻辑**

这就是让电路从“普通编码”升华为“优先编码”的关键：

- **逻辑门实现：** 在电路中间使用了**非门**和**与门**链。
- **屏蔽机制：**  **v1**（假设为最高位组）的信号直接去封锁 **v2, v3, v4** 的路径。
  - 只有当 **v1=0** 时，第二组的信号才能通过；只有当 **v1, v2** 同时为 **0** 时，第三组才能通过。
- **结果：** 这一层确保了**同一时间只有优先级最高的那一组 Y1, Y0 能够到达最后的输出或门**。其他低优先级的信号都被与门强制转成了 `00`，彻底解决“信号叠加”问题。

3. **高位生成与最终汇总**

- **高两位 ($Y_3, Y_2$)：** 将 **v1 ~ v4** 接入了第五个 4-2 模块。这个模块的输出直接代表了“哪一组在工作”，即 16 位编码中的高两位。
- **低两位 ($Y_1, Y_0$)：** 经过拦截逻辑过滤后的 4 组低位信号，通过最后两个**大或门**进行汇总。
- **最终输出：** 此时的 4 位输出（**Y3, Y2** 拼接上汇总后的 **Y1, Y0**）就是完美的 16-4 优先编码结果。

##### 前导0和前导1的计数

优先编码器本质上就是一个“寻找第一个1的电路”

计算“前导0”：优先编码器会输出最高优先级（最高位）的1所在的索引，然后用15-k即可计算出前导0的数量。

计算“前导1”：逻辑基本相同，只是在把16位的数据输入个16-4的优先编码器的时候先进行取反操作，后续操作相同，数量也是15-k。

#### 多路选择器

多路选择器可以根据控制端的输入来从多个数据端中选择一路进行输出. 多路选择器也称"多路复用器", 或简称"选择器". 最简单的选择器是"1位2选1选择器", 它可以根据控制端的输入从两路1位的数据中选择一路进行输出.

当S输入为0时，选择走D0，当输入为1时，选择走D1.

##### 搭建1位2选1选择器

![OneStudentOneChip/image/30.png](../image/30.png)

在计算机中，选择器是使用频率很高的元件，因为计算机的本质是用于处理数据，而数据的来源和处理方式都很多，因此需要大量的选择器来对数据来源和处理结果进行选择。

##### 搭建3位4选1选择器

线路图：

![OneStudentOneChip/image/31.png](../image/31.png)

![OneStudentOneChip/image/32.png](../image/32.png)

解析：上面的线路图作为一个子线路，主要完成1位4选1，主线路中，放置三个1位4选1并联，从而实现3位4选1选择器

##### 重点：

深入拆解：3位4选1选择器

在数字电路中，一个选择器的名字由两个核心维度组成：“选择能力”和“数据宽度”

“4选1”：代表逻辑功能（选哪路？）

- 输入组数：共有4组待选信号
- 选择信号（S线）：需要2位控制位(S1、S0)，因为2x2=4，这两位二进制数正好能产生00、01、10、11四种状态，分别对应4路输入
- 逻辑本质：它本质上是一个”多路开关“，决定哪一个通道的数据可以通往重点

”3位“：代表数据宽度（路有多宽？）

- 单组宽度：每一组输入信号不是1根线，而是3根线
- 同步性：当你选择”第1路“时，这3根线上的信号会同时被传送到输出端

###### 如何判断是”几位几选几“

**第一步：看“选几”——数输入组数**

看输入端被分成了多少个**独立的选项**。

- 有 2 组输入 -> **2选1**
- 有 4 组输入 ->  **4选1**
- 有 8 组输入 ->  **8选1**

> **小技巧**：看选择信号（Select）有几根。如果有 n 根选择线，那么通常就是 2^n 选 1。

**第二步：看“几位”——数每组的线数**

看**每一个选项**由几根线组成。

- 每个选项只有 1 根线  -> **1位**（Bit）
- 每个选项有 8 根线（总线） ->  **8位**
- 在仿真软件（如 Logisim）中，看连线的粗细：细线通常是 1 位，粗线是多位总线。

**第三步：组合名称**

公式：**[每组的位数] 位 [总组数] 选 1**。

##### 搭建可切换进位计数值的七段数码管

![OneStudentOneChip/image/33.png](../image/33.png)

前四位1，2，3，4控制七段晶体管输出，5位信号用于控制选择哪一个显示，当开关S断开，即置零时选择十六进制显示，当开关闭合时，即置一时选择十进制显示。

#### 比较器

比较器用于检查两个输入的每一位是否完全一致. 由于异或门(和同或门)已经具备比较1位数据的功能, 因此可通过异或门(和同或门)搭建多位数据的比较器. 

![OneStudentOneChip/image/34.png](../image/34.png)

当两组输入数据相等时，点亮LED灯。

#### 加法器

全加器，输入有进位的加法器；半加器，输入无进位的加法器。

##### 搭建1位全加器

真值表：

![OneStudentOneChip/image/35.png](../image/35.png)

![OneStudentOneChip/image/36.png](../image/36.png)

##### 搭建1位全加器2

![OneStudentOneChip/image/37.png](../image/37.png)

##### 搭建4位加法器

![OneStudentOneChip/image/38.png](../image/38.png)

在有了前面的一位全加器之后，就可以按照套娃的形式搭建多位的加法器，这里以四位加法器作为例子展示

### 整数的机器级表示

计算机中表示负数的方式，通过一个二进制位来编码整数的符号位，剩下的二进制位用于编码整数的绝对值，这种表示称为“有符号二进制整数”，简称“有符号数”

#### 原码

原码是一种直观的编码方式, 最高位表示符号位, `0`表示正数, `1`表示负数, 其余位表示对应真值的绝对值.

考虑采用8位的RCA进行原码加法：

- 当两数皆为正数时, 通过RCA进行加法所得的结果按原码解释, 与将两数按原码解释后得到的结果在数学意义上相加, 两者一致. 因此, 在这种情况下, 可以直接通过RCA进行原码加法.
- 当两数为负时, RCA所得结果与数学意义不符, 区别在于符号位. 因此, 在这种情况下, 电路需要对符号位进行特殊处理.
- 当仅有一数为负时, RCA所得结果与数学意义不符, 不仅符号位有可能错误, 绝对值也错误. 因此, 在这种情况下, 不能使用RCA进行原码加法.

##### 搭建4位减法器

思路：根据前面的加法器，类推减法器的搭建

1. 首先写出真值表
2. 首先不考虑借位对当前的影响，类似前面的半加器
3. 再考虑结尾对当前减法的影响，类似前面的全加器
4. 再依次堆叠形成4位减法器

真值表：

![OneStudentOneChip/image/39.jpg](../image/39.jpg)

先搭建一个半减器![OneStudentOneChip/image/40.png](../image/40.png)

再优化成全减器![OneStudentOneChip/image/41.png](../image/41.png)

最终按照四位加法器的思路连接电路形成四位减法器：

![OneStudentOneChip/image/42.png](../image/42.png)

##### 搭建4位原码加法器

![OneStudentOneChip/image/43.png](../image/43.png)

在普通的四位加法器上添加了一个符号位，实例化一个晶体管专门来表示负号。

#### 反码

反码是另一种编码方式, 它尝试解决原码加法中涉及负数的问题. 具体地, 对于正数和`0`, 其表示与原码一致; 对于负数, 其表示为相应相反数的原码的按位取反.

- 当两数皆为正数时, 通过RCA进行加法所得的结果按反码解释, 与将两数按反码解释后得到的结果在数学意义上相加, 两者一致. 因此, 在这种情况下, 可以直接通过RCA进行反码加法.
- 当有一数为负时, RCA所得结果与数学意义不符, 虽然符号位正确, 但绝对值部分不正确
- 特别地, 当互为相反数的两数相加时, 根据反码的定义, 结果总是`0b11111111`. 按反码解释, 所得结果的真值为`-0`, 如果将其看成数学意义上的`0`, 则RCA结果正确.

##### 搭建4位反码加法器

![OneStudentOneChip/image/44.png](../image/44.png)

这里的输出的符号判断就比前面单纯的原码加法器要复杂，要考虑多种情况，我这里考虑了三种情况，使用了三个与门，把结果再或门连接到符号输出那里。

目前这里只是实现了RCA计算反码加法，对于-0输入尚不能处理，后续的”搭建4位反码加法器(2)“将完成-0的输入处理。

##### 搭建4位反码加法器(2)

在反码运算中，有一个神奇的规律：

如果加法运算在最高位产生了进位，你只需要把这个进位再加回到结果的最低位上，就能得到正确的反码结果

![OneStudentOneChip/image/45.png](../image/45.png)

这里做的修改是把加法器和减法器的Cout重新连接回Cin，即可实现对-0等的处理.

上图显示了7 + -0 = -8

#### 补码

补码是现代计算机中常用的整数编码方式, 它进一步修复了反码计算错误时结果的偏差. 具体地, 对于正数和`0`, 其表示与原码一致; 对于负数, 其表示为相应相反数的原码的按位取反后加`1`.

这部分在入学答辩之前再仔细复习。

#### 溢出检测

回顾上文的分析, 即使是补码, 也存在编码连续但真值不连续的边界, 即`0b0111...111`和`0b1000...000`之间的边界, 它们分别表示最大数和最小数. 如果加法的计算跨越了这个边界, 计算所得结果将与数学意义不符. 特别地, 这个边界之所以存在, 是因为对于给定的二进制位数, 其表示范围总是有限的, 因此必定存在超过表示范围的数值, 使得真值的分布无法一直连续. **这种计算结果超过编码表示范围的情况, 称为"溢出"(overflow)**. 显然, 如果计算发生溢出, 则所得结果肯定与数学意义不符. 为此, 通常需要在计算加法的同时, 检测结果是否发生溢出.

- 两个正数相加，结果为负数
- 两个负数相加，结果为整数

##### 全加器的真值表：

![OneStudentOneChip/image/46.png](../image/46.png)

##### 测试电路

![OneStudentOneChip/image/47.png](../image/47.png)

### 时序逻辑电路

它可以存储状态，其输出由当前输入和旧状态共同决定

1. 可以读出电路的旧状态
2. 可以更新电路的状态

#### 交叉配对反相器

可以存储状态的最简单电路是交叉配对反相器

![OneStudentOneChip/image/48.png](../image/48.png)

![OneStudentOneChip/image/49.png](../image/49.png)

下表总结了交叉配对反相器的行为：

![OneStudentOneChip/image/50.png](../image/50.png)

#### S-R锁存器

S-R锁存器通过将交叉配对反相器中的反相器换成或非门，来向外部提供控制功能，其中S表示Set，相应控制端用于对锁存器置位（设置为1）；R表示Reset，相应控制端用于对锁存器复位（设置为0），SR锁存器的逻辑符号和电路结构如下：

![OneStudentOneChip/image/51.png](../image/51.png)

根据输入的不同，可以分为4中情况讨论SR锁存器的行为：

1. 当`S=1, R=0`时, 上方或非门的行为和反相器一致, 下方或非门的输出恒为`0`. 此时`Q`为`1`, 故将SR锁存器存储的值更新为`1`.
2. 当`S=0, R=1`时, 上方或非门的输出恒为`0`, 下方或非门的行为和反相器一致. 此时`Q`为`0`, 故将SR锁存器存储的值更新为`0`.
3. 当`S=0, R=0`时, 两个或非门的行为和反相器一致. 此时SR锁存器的行为与交叉配对反相器一致, 故SR锁存器将保持之前存储的值.
4. 当`S=1, R=1`时, 两个或非门的输出恒为`0`, 此时无法表示有效的信息. 同时, 输入从`S=1, R=1`变为`S=0, R=0`时, 相当于让交叉配对反相器进入Q = 0,~Q = 0 的状态. 根据上文的分析, 这将导致SR锁存器进入亚稳态, 因此需要避免.

SR锁存器的行为：![OneStudentOneChip/image/52.png](../image/52.png)

搭建S-R锁存器：![OneStudentOneChip/image/53.png](../image/53.png)

亚稳态：

![OneStudentOneChip/image/54.png](../image/54.png)

##### 用与非门搭建的SR锁存器

真值表和电路图：![OneStudentOneChip/image/55.png](../image/55.png)

![OneStudentOneChip/image/56.png](../image/56.png)

#### D锁存器

为了从源头避免亚稳态，可以在SR锁存器前添加若干门电路，将SR锁存器的4中输入限制成3中合法输入，这就是D锁存器

![OneStudentOneChip/image/57.png](../image/57.png)

其中D为输入数据，WE为写使能(Write Enable)

##### 搭建D锁存器

![OneStudentOneChip/image/58.png](../image/58.png)

D锁存器逻辑行为分析：

- **输入限制**：通过一个非门（Inverter）连接 D，确保了进入内部 SR 锁存器的 S 和 R 信号永远不会同时为 1（或在与非门版本中同时为 0），从而从源头上避免了非法状态。

- **透明性（Transparency）**：当 WE 有效时，输出 Q 会跟随输入 D 的变化，此时锁存器就像是一根透明的导线。

- **锁存（Latch）**：当 WE 无效时，输出 Q 保持不变，无论 D 如何波动。

##### 搭建带复位功能的D锁存器

![OneStudentOneChip/image/59.png](../image/59.png)

##### 用D锁存器实现位翻转功能

![OneStudentOneChip/image/60.png](../image/60.png)

当WE为1时，电路进入了所谓的“透明模式”

- **第一步**：假设当前Q = 0， 则 ~Q = 1.
- **第二步**：由于反馈线，输入 D 瞬间变为 1。
- **第三步**：在 WE=1 时，D=1 会立即让 Q 变为 1。
- **第四步**：一旦 Q = 1，~ Q就变成了 0。反馈线又让 D 变为 0，从而导致 Q 又变回 0。

这个过程会以忽略不计的门延迟速度不断重复，从而导致最终“明显的震荡”

#### 同步电路

通过全局的周期性时钟信号来实现同步。

时钟信号是如下图所示的脉冲信号, 它在高低电平之间来回翻转, 一次高电平和一次低电平加起来称为一个周期. 在同步电路中, 存储元件仅在时钟信号正边沿(positive edge, 从低电平翻转为高电平, 也称上升沿) 或负边沿(negative edge, 从高电平翻转为低电平, 也称下降沿)达到时写入数据, 且能在后续时钟周期稳定读出该数据. 

![OneStudentOneChip/image/61.png](../image/61.png)

#### 异步电路

通过模块之间的局部通信信号来实现同步

相对于异步电路，同步电路的设计较简单，对同步电路的分析也比较容易，尽管由于引入了周期性反转的时钟信号，其功耗要高于异步电路，同步电路仍然被业界广泛采用。但是，D锁存器作为存储元件，却无法满足同步电路的要求，即使将时钟信号连接到D锁存器的写使能端，也仍然不满足上述要求，如下图所示，我们期望数据在时钟上升沿到来时写入存储元件，且在后续时钟周期能从存储元件稳定读出该数据。

但是，因为锁存器属于电平触发的存储元件，只要输入发生变化，锁存器就能立即感知，并将该变化传播到输出端。

#### D触发器

D触发器(D Flip-Flop)是一种边沿触发的存储元件, 它基于锁存器搭建, 但可以在时钟信号维持电平的时刻巧妙地阻塞输入信号的传播. D触发器的逻辑符号如下图所示, 其中左下方的`>`符号表示该端口需要连接时钟信号. 

##### 主从式D触发器

![OneStudentOneChip/image/62.png](../image/62.png)

主从式D触发器由两个D锁存器构成，左边的成为主锁存器，右边的成为从锁存器，两个D锁存器的写使能端分别与时钟信号及其反结果相连，具体工作过程如下：

1. **数据准备阶段.** 此时时钟信号`clk`处于低电平, 故主锁存器的写使能端有效, 数据信号`D`可从外部进入主锁存器; 但由于从锁存器的写使能端无效, 故数据信号无法传播到从锁存器, 因而整个D触发器的输出端`Q`保持不变.
2. **采样阶段.** 当时钟信号`clk`的上升沿到来时, 主锁存器的写使能端无效, 数据信号`D`无法从外部进入主锁存器, `D`的后续变化将无法对主锁存器造成影响, 从而将时钟信号上升沿到来前的外部数据`D`"锁"在主锁存器中. 与此同时, 从锁存器的写使能端开始有效, 主锁存器中"锁住"的数据将传播到从锁存器, 并作为整个D触发器的输出.
3. **维持阶段.** 此时时钟信号`clk`处于高电平, 故主锁存器的写使能端无效, 因此不受数据信号`D`变化的影响; 从锁存器的写使能端虽然有效, 但由于主锁存器保持不变, 故从锁存器也保持不变, 因而整个D触发器的输出端`Q`保持不变.

从整体上看，当时钟上升沿到来时，数据被写入D触发器，并能在后续时钟周期稳定读出该数据 。

##### 搭建D触发器

![OneStudentOneChip/image/63.png](../image/63.png)

##### 搭建带复位功能的D触发器

![OneStudentOneChip/image/64.png](../image/64.png)

##### 用D触发器实现位反转功能

![OneStudentOneChip/image/65.png](../image/65.png)

每点击一次按钮时，输出就翻转一次

##### 搭建下降沿触发的D触发器

就是将主从D寄存器的电平反转即可

![OneStudentOneChip/image/66.png](../image/66.png)

##### 搭建带使能端的D触发器

![OneStudentOneChip/image/67.png](../image/67.png)

##### 维持-阻塞D触发器

![OneStudentOneChip/image/68.png](../image/68.png)

这种触发器属于**上升沿触发**，其精妙之处在于时钟信号clk变化是的反馈逻辑：

1. **准备阶段(clk = 0)**

   当clk为低电平时，中间两个与非门的输出都被强制拉高

   - 右侧的RS锁存器因为输入都是1，进入保持状态
   - 此时D信号的变化只能改变左侧部分门的预备状态，但无法传递到输出端Q

2. **触发时刻(clk 0 -> 1)**

   在clk跳变的瞬间，左侧的控制们会根据此时D的电平，向右侧的RS锁存器发送一个脉冲信号（要么给“置位”端，要么给“复位”端），从而改变Q的值

3. **维持和阻塞阶段(clk = 1)**

   这是该电路名字的由来。一旦输出Q发生了改变，电路内部的反馈线会立即生效：

   - **维持：**它利用内部反馈，锁定当前的输出状态。哪怕此时D端的信号发生剧烈变化，也不会再影响到输出
   - **阻塞：**它通过反馈路径将输入通路”切断“，确保在一个时钟周期内，输出只会在上升沿那一刻改变一次

#### 寄存器

寄存器是由多个D触发器组成的存储元件，结构图如下，这些D触发器之间共享相同的时钟信号和使能信号，从而实现整体存储的效果

##### 搭建四位寄存器

![OneStudentOneChip/image/69.png](../image/69.png)

##### 搭建四位计数器

![OneStudentOneChip/image/70.png](../image/70.png)

上面所有的子电路均在以前的电路中搭建过

##### 设计数列求和电路

![OneStudentOneChip/image/71.png](../image/71.png)

##### 八位寄存器和八位加法器

![OneStudentOneChip/image/72.png](../image/72.png)

![OneStudentOneChip/image/73.png](../image/73.png)

##### 时钟

基本思路如图

![OneStudentOneChip/image/74.png](../image/74.png)

如何实现进位，我是通过加一个比较器来是实现，想进位几就设置一个比较器的另一个输入是几，实现进位，具体可查看电路图。

但是上面方式搭建电路，会导致电路太复杂，后续使用logisim的自带的电路搭建时钟，如下所示：

![OneStudentOneChip/image/75.png](../image/75.png)

时钟，简单版本，采用logisim自带的元器件，主要是计数器和比较器和十六进制数码管以及一些其他输入，这样对比前面用纯电路设计，电路更加简单且容易搭建，作为F3的完结。

### 计算机系统的状态机模型

#### 处理器的组成和工作原理

计算机是一个机械地进行数据处理地装置

##### 指令及其编码

一条指令需要给出两方面的信息：一方面，计算机需要处理的数据有很多，因此指令中需要指定需要处理那些数据，这称为指令的“操作数(operand)”字段；另一方面，计算机处理数据的方式也有很多种，因此指令中也需要指定用何种方式来处理数据，这称为指令的“操作码(opcode)“字段。

##### 存储程序

有些数据处理的中间结果应该保存起来供后续使用，因此处理器中应该有一些部件能够保存处理的数据，这就是寄存器。为了方便存放数据，通常来说这样的寄存器不只一个，而是由多个寄存器组成一个”寄存器组“，由于这样的寄存器组用于处理一般数据，因此也称其为通用寄存器(General Purpose Register, GPR)。相对地，有一些寄存器地功能，并不是用于处理一般处理，它们不属于FPR。

例如, 要计算`1+2+...+10`, 但一条加法指令只能计算两个数据相加的结果, 因此需要将`1+2`的结果保存在GPR中的某个寄存器`r`中, 然后计算`r+3`等等. 这样, 指令就需要在操作数字段中指定从哪个GPR中读出数据, 以及将计算结果存入哪个GPR中. 至于操作码, 处理器只需要约定好每种操作码代表何种操作即可.

处理器作为一个数字电路，所有信息都可以用0和1来表示，指令也不除外，例如，某个简单处理器由4个GPR，支持3种指令，其中2种如下：

```
 7  6 5  4 3   2 1   0
+----+----+-----+-----+
| 00 | rd | rs1 | rs2 | R[rd]=R[rs1]+R[rs2]    add指令, 寄存器相加
+----+----+-----+-----+
| 10 | rd |    imm    | R[rd]=imm              li指令, 装入立即数, 高位补0
+----+----+-----+-----+
```

由于指令只有3种，因此最少可以用2位操作码就能区分所有指令，在上述例子中，操作码是00，表示**add**指令；操作码是10，表示**li**指令。

关于操作数, 因为GPR只有4个, 因此可以用2位来指定一个GPR的地址(`00`, `01`, `10`, `11`). 操作数据的来源称为"源寄存器", 上述的`add`指令需要从两个源寄存器中获取加数, 两个源寄存器的地址分别记为`rs1`和`rs2`, 分别用`R[rs1]`和`R[rs2]`来表示GPR中存放的内容; 操作需要写入的目的称为"目的寄存器", 一般记为`rd`. 其中, 第2条`li`指令的操作数稍有不同, 其源操作数不再是GPR, 而是直接将指令中的`imm`字段解析成一个二进制数来使用, 这种操作数称为"立即数".

```
00100001   add指令, 将R[0]和R[1]相加, 结果写入R[2]
10110000   li指令, 将立即数0000写入R[3]
10000101   li指令, 将立即数0101写入R[0]
```

```
 7  6 5         2 1  0
+----+---- -----+-----+
| 11 |   addr   | rs2 | if (R[0]!=R[rs2]) PC=addr bner0指令, 若不等于R[0]则跳转
+----+----------+-----+
```

这条`bner0`指令十分特殊, 它是`Branch if Not Equal r0`的缩写, 如果执行这条指令的时候`R[rs2]`与`R[0]`不相等, 则将PC寄存器更新为`addr`, 即让PC指向`addr`处的指令. 不过, PC寄存器并不是用于处理一般数据, 因此它不属于GPR.

计算机地工作机制：它可以让程序来自动控制计算机的执行，具体地，我们可以先把一段指令序列放到存储器(如现代计算机地内存)中，让计算机从内存中取出指令来执行；重要的是，当计算机执行完一条指令之后，就继续执行下一条指令。为了能让计算机知道下一条指令在哪里，还需要一个用于执行当前执行到那条指令地部件，这个部件称为”程序计数器“(Program Counter, PC)

##### 一个数列求和地例子

```
0: li r0, 10   # 这里是十进制的10
1: li r1, 0
2: li r2, 0
3: li r3, 1
4: add r1, r1, r3
5: add r2, r2, r1
6: bner0 r1, 4
7: bner0 r3, 7
```

为了理解指令执行的过程, 我们还需要记录寄存器的变化. 我们用`(PC, r0, r1, r2, r3)`的格式来记录寄存器的值, 这一格式也反映了处理器所处的状态. 例如`(7, 2, 3, 1, 8)`表示接下来将要执行编号为`7`的指令, 当前4个GPR的值分别为`2`, `3`, `1`, `8`. 我们约定在开始的时刻, 处理器的状态是`(0, 0, 0, 0, 0)`. 以下是处理器执行前若干条指令的过程:

```
PC r0 r1 r2 r3
(0, 0, 0, 0, 0)   # 初始状态
(1, 10, 0, 0, 0)  # 执行PC为0的指令后, r0更新为10, PC更新为下一条指令的位置
(2, 10, 0, 0, 0)  # 执行PC为1的指令后, r1更新为0, PC更新为下一条指令的位置
(3, 10, 0, 0, 0)  # 执行PC为2的指令后, r2更新为0, PC更新为下一条指令的位置
(4, 10, 0, 0, 1)  # 执行PC为3的指令后, r3更新为1, PC更新为下一条指令的位置
(5, 10, 1, 0, 1)  # 执行PC为4的指令后, r1更新为r1+r3, PC更新为下一条指令的位置
(6, 10, 1, 1, 1)  # 执行PC为5的指令后, r2更新为r2+r1, PC更新为下一条指令的位置
(4, 10, 1, 1, 1)  # 执行PC为6的指令后, 因r1不等于r0, 故PC更新为4
(5, 10, 2, 1, 1)  # 执行PC为4的指令后, r1更新为r1+r3, PC更新为下一条指令的位置
(6, 10, 2, 3, 1)  
(4, 10, 2, 3, 1)
(5, 10, 3, 3, 1)
(6, 10, 3, 6, 1)
(4, 10, 3, 6, 1)
(5, 10, 4, 6, 1)
(6, 10, 4, 10, 1)
(4, 10, 4, 10, 1)
(5, 10, 5, 10, 1)
(6, 10, 5, 15, 1)
(4, 10, 5, 15, 1)
(5, 10, 6, 15, 1)
(6, 10, 6, 21, 1)
(4, 10, 6, 21, 1)
(5, 10, 7, 21, 1)
(6, 10, 7, 28, 1)
(4, 10, 7, 28, 1)
(5, 10, 8, 28, 1)
(6, 10, 8, 36, 1)
(4, 10, 8, 36, 1)
(5, 10, 9, 36, 1)
(6, 10, 9, 45, 1)
(4, 10, 9, 45, 1)
(5, 10, 10, 45, 1)
(6, 10, 10, 55, 1)
(7, 10, 10, 55, 1)
8->7->8->7...
```

执行到最后的时候，处理器处于7、8循环的状态，上述数列地求和结果在r2寄存器中。

所以说，处理器的工作过程就是**按照指令的含义机械地更新寄存器地状态**。

事实上, 计算机的优势在于其极快的运算速度: 现代处理器的主频已经到GHz量级了, 以2GHz为例, 这意味着处理器在1秒内会经过2000000000个时钟周期. 而用上述指令序列计算`1+2+...+10`只需要不到40条指令, 如果按每周期执行1条指令来计算, 现代处理器只需要花费0.00000002s, 即20ns, 即可完成计算. 如果我们人工按电子计算器, 1秒按10个键已经算是手速非常快了, 但输入`1+2+...+10=`需要按22次按键, 算下来也需要2s. 如果要计算`1+2+...+10000`, 我们只需要将上述PC为0的指令改为`li r0, 10000`即可 (不过需要更长的指令来表示`10000`这个立即数), 按同样的方式计算, 需要执行约30000条指令, 也只需要花费0.000015s, 即15us. 如果人工按电子计算器, 则需要按48894次按键, 算下来需要4889s! 即使我们用等差数列的求和公式心算(`(10000 + 1) * 10000 / 2`), 也需要若干秒才能算出正确答案, 和强大的计算机相比可谓是相形见绌

##### 重新审视编程

上述地**add**和**li**等指令，在计算机领域里面属于汇编语言的范畴，汇编语言是指令的符号化表示，与汇编语言相比，还有更底层的机器语言，他就是指令的二进制表示，可以被通过数字电路实现的处理器直接执行，例如上面数列求和的及其语言就可以表示如下。

```
10001010    # 0: li r0, 10
10010000    # 1: li r1, 0
10100000    # 2: li r2, 0
10110001    # 3: li r3, 1
00010111    # 4: add r1, r1, r3
00101001    # 5: add r2, r2, r1
11010001    # 6: bner0 r1, 4
11011111    # 7: bner0 r3, 7
```

事实上，上述机器语言表示的就是根据前文约定的指令汇编将汇编语言翻译成0和1的序列，只要了解指令的编码规则，汇编语言和及其语言可以互相转化，不过如果只看机器语言，程序员是很难理解的，相比之下，汇编语言能更直观的表示指令的操作码和操作数，可读性比机器语言更好。

##### 计算10以内的奇数之和

```
0: li r0, 9
1: li r1, 1
2: li r2, 1
3: li r3, 2
4: add r1, r1, r3
5: add r2, r2, r1
6: bner0 r1, 4
7: bner0 r3, 7
```

处理器状态的变化过程

```
PC r0 r1 r2 r3
(0, 0, 0, 0, 0)
(1, 9, 0, 0, 0)
(2, 9, 1, 0, 0)
(3, 9, 1, 1, 0)
(4, 9, 1, 1, 2)
(5, 9, 3, 1, 2)
(6, 9, 3, 4, 2)
(4, 9, 3, 4, 2)
(5, 9, 5, 4, 2)
(6, 9, 5, 9, 2)
(4, 9, 5, 9, 2)
(5, 9, 7, 9, 2)
(6, 9, 7, 16, 2)
(4, 9, 7, 16, 2)
(5, 9, 9, 16, 2)
(6, 9, 9, 25, 2)
```

#### 指令集架构地状态机模型

GPR、PC、存储器，指令及其执行过程，在计算机领域中属于指令集架构(Instruction Set Architecture, 缩写位ISAS，也简称指令集)的范畴。事实上x86, ARM, RISC-V等其实都是ISA。

##### 状态机

状态机的定义包含如下部分：

![OneStudentOneChip/image/76.png](../image/76.png)

从状态机的视角理解ISA：

- 状态集合. 回忆时序逻辑电路的相关内容, 状态是那些可以稳定存储信息的元素. 对这个含义进行引申, 在ISA中, 状态应该包含PC, GPR和内存. 也即, ISA中的一个状态是一组具体的PC, GPR和内存, 而全体状态的集合S则是PC, GPR和内存所有取值的组合, 即S = {(PC, R, M)}
- 激励事件集合. 在ISA中, 执行指令会改变状态, 因此执行指令就是这个状态机的激励事件.
- 状态转移规则. 按照定义, 在ISA中, 状态转移规则用于描述“在某个状态下执行某指令后的次态”, 也即指令的语义, 它约定了执行某指令后, 状态应该发生怎么样的变化, 从而从一个状态转移到另一个.
- 初始状态. 在未执行任何指令之前的状态

对于x86，ARM，RISC-V这些商用级别的真实ISA，它们的GPR数量更多，指令数量更多，指令行为也更复杂，但其本质原理和上述只有3条指令的sISA并没有本质区别。

### C程序入门

在线编程网址：[Compiler Explorer](https://godbolt.org/)

#### C程序的状态机模型

从状态机的视角来理解C程序

![OneStudentOneChip/image/77.png](../image/77.png)

用C语言实现数列求和

```
#include <stdio.h>

/* 1 */ int main() {
/* 2 */   int sum = 0;
/* 3 */   int i = 1;
/* 4 */   do {
/* 5 */     sum = sum + i;
/* 6 */     i = i + 1;
/* 7 */   } while (i <= 10);
/* 8 */   printf("sum = %d\n", sum);
/* 9 */   return 0;
/* 10*/ }
```

和前面汇编语言相比，C语言开发程序有以下两点优势：

1. 变量的命名可以更直观地反映出其用途，但汇编语言中，GPR的用途只能根据上下文推断。
2. 循环的表达更清晰，可以直接区别循环条件和循环体，但在汇编语言中，循环条件和循环体都是指令，需要根据上下文推断。

```
PC sum i
(2, ?, ?)    # 初始状态
(3, 0, ?)    # 执行PC为2的语句后, sum更新为0, PC更新为下一条语句的位置
(5, 0, 1)    # 执行PC为3的语句后, i更新为1, PC更新为下一条语句的位置(第4行无有效操作, 跳过)
(6, 1, 1)    # 执行PC为5的语句后, sum更新为sum + i, PC更新为下一条语句的位置
(7, 1, 2)    # 执行PC为6的语句后, i更新为i + 1, PC更新为下一条语句的位置
(5, 1, 2)    # 执行PC为7的语句后, 由于循环条件i <= 10成立, 因此重新进入循环体
(6, 3, 2)
(7, 3, 3)
(5, 3, 3)
(6, 6, 3)
(7, 6, 4)
(5, 6, 4)
(6, 10, 4)
(7, 10, 5)
(5, 10, 5)
(6, 15, 5)
(7, 15, 6)
(5, 15, 6)
(6, 21, 6)
(7, 21, 7)
(5, 21, 7)
(6, 28, 7)
(7, 28, 8)
(5, 28, 8)
(6, 36, 8)
(7, 36, 9)
(5, 36, 9)
(6, 45, 9)
(7, 45, 10)
(5, 45, 10)
(6, 55, 10)
(7, 55, 11)
(8, 55, 11)
(9, 55, 11)
(10, 55, 11) # 程序结束时的状态
```

### 数字电路的状态机模型

从状态机的角度去看数字电路

- 状态集合。在数字电路中，只有时序逻辑电路才能存储信息，因此一个状态是时序逻辑元件所存储的具体信息，而全体状态的集合S则是时序逻辑元件所能存储信息的所有组合。

- 激励事件集合。既然时序逻辑元件表征了数字电路的状态，而时序逻辑元件的内部状态可以通过其输入端改变（例如可以通过输入端将数据写入D触发器），我们可以见数字电路看成以下模型：

  ```
      +------------------+
  +-->| Sequential Logic |----+
  |   +------------------+    |
  | next state                | current state
  |                           |
  |  +---------------------+  |
  +--| Combinational Logic |<-+
     +---------------------+
  ```

  也即，让时序逻辑元件的状态发生变化的，其实是组合逻辑电路输出的信号，因此组合逻辑电路就是这个状态机的激励事件。

- 状态转移规则。时序逻辑元件的状态具体如何变化，是由组合逻辑电路的具体逻辑决定的。

- 初始状态，即电路在复位时，时序逻辑元件的状态。

Johnson计数器的电路结构如下：

![OneStudentOneChip/image/78.png](../image/78.png)

从状态机视角来解释上述Johnson计数器的工作过程：

```
 A  B  C  D
(0, 0, 0, 0)    # 初始状态
(1, 0, 0, 0)
(1, 1, 0, 0)
(1, 1, 1, 0)
(1, 1, 1, 1)
(0, 1, 1, 1)
(0, 0, 1, 1)
(0, 0, 0, 1)
(0, 0, 0, 0)    # 与初始状态一致
```

#### 从状态机视角理解数列求和电路的工作过程

![OneStudentOneChip/image/79.png](../image/79.png)

规定左边寄存器A，右边寄存器B

```
A	B
(0, 0)
(1, 0)
(2, 1)
(3, 3)
(4, 6)
(5, 10)
(6, 15)
(7, 21)
(8, 28)
(9, 36)
(10, 45)
(11, 55)
```

### 在计算机上执行C程序

#### 编译 = 将C程序翻译成指令序列

这个过程在计算机系统中有一个特殊的名称, 叫"编译"(compile). 从原则上讲, 编译的工作可以人工进行, 但现代程序的规模很大, 人工进行编译是非常繁琐的, 因此通常由一类特殊的程序来开展编译工作, 这类特殊的程序称为"编译器"(compiler).

编译器的工作就是将C程序的状态机翻译成ISA的状态机

编译器需要完成以下工作：

- 将C程序的状态翻译成ISA的状态, 也即
  - 将C程序的PC对应到ISA的PC
  - 将C程序的变量对应到ISA的GPR或内存
- 将C程序的状态转移规则翻译成ISA的状态转移规则, 也即, 将语句翻译成指令序列

#### 结合数列求和的例子理解编译器的工作

编译器不仅仅是把一种文字翻译成另一种文字，它本质上是在做一个**“状态转移的等价映射”**

编译器到底在做什么？

编译器的工作可以被理解为：**确保指令序列状态机的运行轨迹，在逻辑上与C语言状态机的运行轨迹完全一致**。

映射关系：

1. **变量映射：** 编译器决定把 C 语言里的 `sum` 映射到哪个寄存器（比如 `%rax`）。
2. **动作映射：** 编译器把 C 语言里的 `sum += i` 映射成一系列指令（如 `add %rcx, %rax`）。
3. **控制流映射：** 编译器把 C 语言里的 `for` 循环映射成一组 `cmp`（比较）和 `jne`（跳转）指令，确保状态机在达到终止条件时能正确跳出。

- **理解优化：** 编译器发现某个变量 `i` 在循环外没用，它可能根本不给 `i` 分配内存，直接用寄存器算完就丢弃。这就是在保证“最终状态”正确的前提下，精简了中间的“状态转移”。
- **理解调试：** 当你在 GDB 里单步执行时，你其实就是在观察这个状态机每一步的变化。
- **理解并发：** 为什么多线程会出问题？因为两个状态机在同时修改同一块内存状态，导致转移过程乱套了。

![OneStudentOneChip/image/80.png](../image/80.png)

#### CPU设计 = 根据ISA设计数字电路

CPU设计的工作就是用数字电路的状态机实现ISA的状态机

具体地，CPU设计需要完成以下工作：

- 用数字电路的状态实现ISA的状态，也即，用时序逻辑电路实现PC，GPR和内存
- 用数字电路的状态转移规则实现ISA的状态转移规则，也即，用组合逻辑电路实现指令的功能

### 程序，ISA和CPU之间的联系

1. 根据ISA手册的功能描述，画一张CPU的结构图 -> 处理器微结构设计
2. 根据结构图设计具体的电路 -> 逻辑设计
3. 开发程序 -> 软件编程
4. 将程序翻译成ISA手册中描述的指令序列 -> 编译
5. 在CPU上执行程序 = 用程序编译出的指令序列控制CPU电路进行状态转移
   - 此时，三个状态机产生联系：Sc ~ Sisa ~ Scpu